class Autocorrelacion implements AudioListener { 
  float sample_rate = 0; //velocidad de muestra
  float last_period = 0; 
  float current_frequency = 0;
  long t; 

  
   final float F0min = 440;
   final float F0max = 1109;
   int min_shift;
   int max_shift;
   
   
  Autocorrelacion () {
    t = 0;
  }
  
  
  synchronized void StoreFrequency(float f) {
    current_frequency = f;
  }
  
  synchronized float GetFrequency() {
    return current_frequency;
  }
  
  void SetSampleRate(float s) {
     sample_rate = s;
     float tmin = 1.0 / F0max;
     float tmax = 1.0 / F0min;
     min_shift = int( tmin * sample_rate ); 
     max_shift = int( tmax * sample_rate );
     System.out.println(min_shift + " " + max_shift);
     last_period = max_shift;
     t = 0;
  }
  
  synchronized void samples(float[] samp) {
    AMDF(samp);
  }
  
  synchronized void samples(float[] sampL, float[] sampR) {
    AMDF(sampL);
  }
  
  synchronized long GetTime() {
    return t;
  }
 
  void AMDF (float []audio) {
    t++;
    int buffer_index = 0;
        
    float max_sum = 0;   
    int period = 0;
    for (int shift = min_shift; shift < max_shift; shift++)
    { 
      float mod = (float)(shift - min_shift) / (float)(max_shift - min_shift);
      mod *= 1.0 - 1.0 / (1.0 + abs(shift - last_period));
      

      float dif = 0;
      for (int i = shift; i < audio.length; i++)
        dif += audio[i] * audio[i - shift];    
        
        
      dif *= 1.0 + mod;
     
      if (dif > max_sum)
      {
        max_sum = dif;       
        period = shift;
      }
    }  
    
    if (period != 0)
    {
      last_period = period;
      float freq = 1.0 / (float)period;
      freq *= (float)sample_rate;        
      StoreFrequency(freq);
      buffer_index += period + min_shift;      
    }
    else {
      last_period = (max_shift + min_shift) / 2;
      StoreFrequency(0);
      buffer_index += min_shift;
    }
  }
  
};
